# Path: backend/pytest.ini
# Version: 7
# Optimized for parallel execution

[pytest]
# Test discovery
python_files = test_*.py
python_classes = Test*
python_functions = test_*
testpaths = tests

# Asyncio configuration
asyncio_mode = auto
asyncio_default_fixture_loop_scope = function

# Dev container environment variables
env =
    TESTCONTAINERS_RYUK_DISABLED=true
    DOCKER_HOST=unix:///var/run/docker.sock

# Coverage configuration
addopts =
    --strict-markers
    --strict-config
    -ra
    --cov-report=term-missing:skip-covered
    --cov-report=html
    --cov-report=xml
    --cov-branch
    --tb=short

# Markers
markers =
    unit: Unit tests (fast, using mocks)
    integration: Integration tests (require Docker containers)
    integration_slow: Integration tests with function scope (complete isolation)
    integration_fast: Integration tests with module scope (shared container)
    e2e: End-to-end tests (full application stack)
    slow: Slow tests (may take several seconds)

# Logging
log_cli = false
log_cli_level = ERROR
log_file = tests.log
log_file_level = ERROR
log_cli_format = %(asctime)s [%(levelname)8s] %(message)s
log_cli_date_format = %Y-%m-%d %H:%M:%S

# Warnings
filterwarnings =
    error
    ignore::UserWarning
    ignore::DeprecationWarning

# Parallel execution settings (for pytest-xdist)
# Distribute tests by file (one file = one worker task)
# Best for integration tests with containers
dist = loadfile

[coverage:run]
source = src
omit =
    */tests/*
    */migrations/*
    */scripts/*
    */__init__.py
# Parallel coverage for xdist
parallel = true
concurrency = multiprocessing

[coverage:report]
precision = 2
show_missing = True
skip_covered = False
fail_under = 70.0
exclude_lines =
    pragma: no cover
    def __repr__
    raise AssertionError
    raise NotImplementedError
    if __name__ == .__main__.:
    if TYPE_CHECKING:
    @abstractmethod